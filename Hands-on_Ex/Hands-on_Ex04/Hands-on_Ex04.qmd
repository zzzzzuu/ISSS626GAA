---
title: "Hands-on Exercise 04"
author: "Leow Xian Zu"
date: "15 Sep 2024"
date-modified: "last-modified"
execute:
  eval: true
  echo: true 
  message: false #no more warning message
  freeze: true #whatever document already commited does not render
---

# Set up

## Load packages

```{r}
pacman::p_load(sf, spdep, tmap, tidyverse, knitr)
```

## Importing data

```{r}
hunan <- st_read(dsn = "data/geospatial", 
                 layer = "Hunan")
hunan2012 <- read_csv("data/aspatial/Hunan_2012.csv")
```

## Left join

```{r}
hunan <- left_join(hunan, hunan2012) %>%
  dplyr::select(1:4, 7, 15)
```

# Visualisation of development indicator

```{r}
basemap <- tm_shape(hunan) +
  tm_polygons() +
  tm_text("NAME_3", size=0.5)

gdppc <- qtm(hunan, "GDPPC")
tmap_arrange(basemap, gdppc, asp=1, ncol=2)
```

## **Computing QUEEN**

```{r}
wm_q <- poly2nb(hunan, queen=TRUE)
summary(wm_q)
```

The summary report above shows that there are 88 area units in Hunan. The most connected area unit has 11 neighbours. There are two area units with only one heighbours.

For each polygon in our polygon object, *wm_q* lists all neighboring polygons. For example, to see the neighbors for the first polygon in the object, type:

```{r}
wm_q[[1]]
```

Polygon 1 has 5 neighbors. The numbers represent the polygon IDs as stored in hunan SpatialPolygonsDataFrame class.

We can retrive the county name of Polygon ID=1 by using the code chunk below:

```{r}
hunan$County[1]

```

To reveal the county names of the five neighboring polygons, the code chunk will be used, then we can retrieve the GDPPC of these five countries by using the code chunk below.

```{r}
hunan$NAME_3[c(2,3,4,57,85)]
nb1 <- wm_q[[1]]
nb1 <- hunan$GDPPC[nb1]
nb1
```

## Computing ROOK

```{r}
wm_r <- poly2nb(hunan, queen=FALSE)
summary(wm_r)
```

### **Visualising contiguity weights**

```{r}
longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])
latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])
coords <- cbind(longitude, latitude)
head(coords)
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
```

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

## A look at queen and rook contiguity

```{r}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey", main="Queen Contiguity")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
plot(hunan$geometry, border="lightgrey", main="Rook Contiguity")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

# Computing distance based neighbours

## Cut off distance

```{r}
#coords <- coordinates(hunan)
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)
```

## Computing fixed distance weight matrix

```{r}
wm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)
wm_d62

```

The value `3.681818` means that, on average, each region in the dataset has approximately 3.68 neighbours. This is derived by dividing the total number of links (324) by the number of regions (88). Some regions may have more or fewer neighbours, but on average, they each have about 3.68 connections with other regions.

```{r}
table(hunan$County, card(wm_d62))
```
