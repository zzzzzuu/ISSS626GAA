{
  "hash": "ea8584aa5b46805cf0356518ecf7a185",
  "result": {
    "markdown": "---\ntitle: \"Take-home Exercise 1\"\nauthor: \"Leow Xian Zu\"\ndate: \"2 Sep 2024\"\ndate-modified: \"last-modified\"\nexecute:\n  eval: true\n  echo: true \n  message: false #no more warning message\n  freeze: true #whatever document already commited does not render\n---\n\n\n# Set up\n\n## Load packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(\n  readr,       # for importing data\n  tidyverse,    # for data manipulation and visualization\n  sf,           # for spatial data handling\n  tmap,         # for thematic maps\n  lubridate,    # for date/time manipulation\n  spatstat,     # for point pattern analysis\n  ggstatsplot,  # for statistical data viz\n  maptools,     # for spatial object manipulation\n  raster,       # for raster data handling\n  sp,           # for spatial data classes and methods\n  leaflet,      # for interactive maps\n  ggplot2,      # for advanced plotting\n  spNetwork     # for spatial network analysis\n)\n```\n:::\n\n\n## Load files\n\nIn this section, we will load and prepare the datasets necessary for our analysis of road traffic accidents in the Bangkok Metropolitan Region (BMR). The BMR, also known as Greater Bangkok, encompasses the city of Bangkok and its surrounding provinces. According to Wikipedia, this area includes Bangkok itself and five adjacent provinces: Nakhon Pathom, Pathum Thani, Nonthaburi, Samut Prakan, and Samut Sakhon. Our analysis will focus on this region, which serves as the political, economic, and cultural heart of Thailand.\n\nWe'll be working with three primary datasets: Thailand Road Accident data from 2019-2022, road network data from OpenStreetMap, and administrative boundary data. These datasets will allow us to conduct a comprehensive spatio-temporal analysis of road traffic accidents in this densely populated and economically significant area of Thailand.\n\n## Data Wrangling 1: Correct Coordinate Reference System\n\nIn preparing our analysis of road traffic accidents in the Bangkok Metropolitan Region, care is taken to ensure our data is accurate and spatially consistent. First, we import the road accident data from 2019 to 2022 using `read_csv()`, a function chosen for its robust handling of various CSV formats (includes automatic reading of headers and correct tagging of date and time columns). Crucially, we filter out records with missing or empty longitude and latitude values. This step is vital as geographic coordinates are the cornerstone of our spatial analysis; including records without valid locations would skew our results and potentially lead to misleading conclusions about accident patterns.\n\nWe then transform this data into a spatial format using `st_as_sf()`. This conversion is essential as it allows us to perform spatial operations and visualisations. We specify the coordinate reference system (CRS) as EPSG:32647, which is tailored for Thailand. This was double-checked on https://epsg.io/. This choice is deliberate - using a local CRS ensures more accurate distance calculations and area representations compared to a global system like WGS84. For the road network data, sourced from OpenStreetMap, we employ `st_read()` to load the shapefile. Recognizing that OSM data can sometimes contain geometry inconsistencies, we apply `st_make_valid()`. This crucial step corrects any invalid geometries that could potentially crash our analysis or produce erroneous results in spatial operations. Lastly, we import administrative boundary data, again ensuring it aligns with our chosen CRS.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrdacc_sf <- read_csv(\"C:/zzzzzuu/ISSS626GAA/Take-home_Ex/Take-home_Ex01/data/thai_road_accident_2019_2022.csv\") %>%\n  filter(!is.na(longitude) & longitude != \"\",\n         !is.na(latitude) & latitude != \"\") %>%\n  st_as_sf(coords = c(\n    \"longitude\", \"latitude\"),\n    crs=4326) %>%  #WGS84, decimel degree\n  st_transform(crs = 32647)  #32647 is Thai's\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 81735 Columns: 18\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (10): province_th, province_en, agency, route, vehicle_type, presumed_c...\ndbl   (6): acc_code, number_of_vehicles_involved, number_of_fatalities, numb...\ndttm  (2): incident_datetime, report_datetime\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\n#read_csv from Readr is better than read.csv base R. It matters for headers with spacing, and also can autodetect dates. \n\nroads_sf <- st_read(\"C:/zzzzzuu/ISSS626GAA/Take-home_Ex/Take-home_Ex01/data/hotosm_tha_roads_lines_shp.shp\") %>%\n  st_make_valid() %>%\n  st_set_crs(4326) %>%\n  st_transform(crs = 32647)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `hotosm_tha_roads_lines_shp' from data source \n  `C:\\zzzzzuu\\ISSS626GAA\\Take-home_Ex\\Take-home_Ex01\\data\\hotosm_tha_roads_lines_shp.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 2792590 features and 14 fields\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: 97.34457 ymin: 5.643645 xmax: 105.6528 ymax: 20.47168\nCRS:           NA\n```\n:::\n\n```{.r .cell-code}\nadmin_sf <- st_read(dsn = \"C:/zzzzzuu/ISSS626GAA/Take-Home_Ex/Take-Home_Ex01/data\", layer = \"tha_admbnda_adm1_rtsd_20220121\") %>%\n  st_set_crs(4326) %>%\n  st_transform(crs = 32647)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `tha_admbnda_adm1_rtsd_20220121' from data source \n  `C:\\zzzzzuu\\ISSS626GAA\\Take-home_Ex\\Take-home_Ex01\\data' using driver `ESRI Shapefile'\nSimple feature collection with 77 features and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 97.34336 ymin: 5.613038 xmax: 105.637 ymax: 20.46507\nGeodetic CRS:  WGS 84\n```\n:::\n:::\n\n\nNeed to check unit of measurement!!!! See how to convert.\n\n::: callout-tip\n## Check that the files are in sf format\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(admin_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"sf\"         \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\nclass(rdacc_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\nclass(roads_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"sf\"         \"data.frame\"\n```\n:::\n:::\n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(admin_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"sf\"         \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\nclass(rdacc_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"sf\"         \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n\n```{.r .cell-code}\nclass(roads_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"sf\"         \"data.frame\"\n```\n:::\n:::\n\n\n## Data Wrangling 2: Filtering to a smaller subset of data\n\nThe initial datasets cover all of Thailand and include various road types. To focus on the Bangkok Metropolitan Region (BMR), a spatial filter is applied to extract data for Bangkok and its five adjacent provinces: Nakhon Pathom, Pathum Thani, Nonthaburi, Samut Prakan, and Samut Sakhon. This step reduces data volume and ensures geographic relevance. Additionally, the road network data is filtered to include only roads accessible to motor vehicles, excluding roads like pedestrian paths and cycling lanes. These filtering processes enhance the accuracy of the subsequent analysis by focusing on relevant geographic areas and road types where motor vehicle accidents are likely to occur.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbangkok_areas <- c(\"Bangkok\",\n                   \"Nonthaburi\",\n                   \"Samut Prakan\",\n                   \"Pathum Thani\",\n                   \"Samut Sakhon\",\n                   \"Nakhon Pathom\")\n\nadmin_sf_bkk <- admin_sf %>%\n  filter(!is.na(ADM1_EN) & ADM1_EN %in% bangkok_areas)\nunique(admin_sf_bkk$ADM1_EN)     #check\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Bangkok\"       \"Samut Prakan\"  \"Nonthaburi\"    \"Pathum Thani\" \n[5] \"Nakhon Pathom\" \"Samut Sakhon\" \n```\n:::\n\n```{.r .cell-code}\nplot(st_geometry(admin_sf_bkk))  #check\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code}\nst_geometry_type(admin_sf_bkk)   #check\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] MULTIPOLYGON MULTIPOLYGON MULTIPOLYGON MULTIPOLYGON MULTIPOLYGON\n[6] MULTIPOLYGON\n18 Levels: GEOMETRY POINT LINESTRING POLYGON MULTIPOINT ... TRIANGLE\n```\n:::\n\n```{.r .cell-code}\nrdacc_sf_bkk <- rdacc_sf %>%\n  filter(!is.na(province_en) & province_en %in% bangkok_areas)\nunique(rdacc_sf_bkk$province_en) #check\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Nakhon Pathom\" \"Nonthaburi\"    \"Samut Prakan\"  \"Bangkok\"      \n[5] \"Samut Sakhon\"  \"Pathum Thani\" \n```\n:::\n\n```{.r .cell-code}\nplot(st_geometry(rdacc_sf_bkk))  #check\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n\n```{.r .cell-code}\nroads_sf_bkk <- st_intersection(roads_sf, admin_sf_bkk)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: attribute variables are assumed to be spatially constant throughout\nall geometries\n```\n:::\n\n```{.r .cell-code}\nunique(roads_sf_bkk$highway)     #check\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"secondary\"      \"residential\"    \"secondary_link\" \"service\"       \n [5] \"footway\"        \"track\"          \"tertiary\"       \"primary\"       \n [9] \"primary_link\"   \"unclassified\"   \"cycleway\"       \"path\"          \n[13] \"steps\"          \"trunk_link\"     \"motorway_link\"  \"motorway\"      \n[17] \"construction\"   \"trunk\"          \"pedestrian\"     \"corridor\"      \n[21] \"tertiary_link\"  \"raceway\"        \"busway\"         \"road\"          \n[25] \"bridleway\"      \"proposed\"      \n```\n:::\n\n```{.r .cell-code}\nroads_sf_bkk_veh <- roads_sf_bkk %>%\n  filter(!is.na(highway) & \n           !(highway %in% c(\"pedestrian\",\n                            \"bridleway\",\n                            \"cycleway\",\n                            \"footway\",\n                            \"steps\",\n                            \"path\")))\nplot(st_geometry(roads_sf_bkk_veh)) #check\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-5-3.png){width=672}\n:::\n:::\n\n\n::: callout-tip\n## Thailand Highway Classification\n\nRefer to https://wiki.openstreetmap.org/wiki/WikiProject_Thailand#Highway_classification for definitions of different roads and access that is legally allowed.\n:::\n\n## Converting MULTILINESTRINGs to LINESTRINGs\n\nThe road network data contains both linestrings and multilinestrings. Multilinestrings represent complex road segments with multiple connected lines, while linestrings are single, continuous lines. Converting all geometries to linestrings simplifies the data structure, ensuring uniformity across the dataset, and makes it easier for lixelisation. This conversion is necessary for consistent analysis, as many spatial operations work more efficiently with simple linestring geometries.\n\n## Check that incident time and report time are in proper format\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(rdacc_sf_bkk$incident_datetime)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"POSIXct\" \"POSIXt\" \n```\n:::\n\n```{.r .cell-code}\nclass(rdacc_sf_bkk$report_datetime)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"POSIXct\" \"POSIXt\" \n```\n:::\n:::\n\n\nincident_datetime and report_datetime is in POSIXct, which is a datetime structure. It captures, year month date, and time. We can explicitly request for the month of the day... year... day of the year... so on and so forth. This will not appear if it is read.csv!\n\nLubridate allows us to extract which month of the year, which date of the week from the two fields. Lubridate has functions like day(), wday(), month() to get the respective.\n\nHere's an example of getting month column by using lubridate:\n\nAfter reading %\\>%\n\nmutate(Month = month(incident_datetime))\n\nmutate(Month_fac = month(incident_datetime,\n\nlabel = TRUE,\n\nabbr = TRUE))\n\nThis will derive a field with month column. We can also change it to day of week.\n\n%\\>%\n\nmutate(Dayofweek = wday(incident_datetime))\n\nAfter done, use write_rds(acc, \"data/rds/acc.rds\")\n\nThis will save the file\n\nNow the processing file is redundance, insert **#\\| eval: false** to reduce computation.\n\nTo use the tidy clean file, we should use \"acc \\<- read_rds(\"data/rds/acc.rds\") It should work.\n\nNeed to convert accident data from csv to sf\n\nConsider creating folder called sandbox.\n\nas long as it's in data folder, it will not push over.\n\nnetworks have to be in LINESTRING version. not MULTILINE. MULTILINE STRING don't work. If we happen to have that, use SF to break into single line. Pay attention because in openstreetmap it will be multi line string. Will give error message in code.\n\nJunction? it's in the accident datapoint.\n\nBangkok metropolitan region. The way we use it is to use the names of the provinces in the wiki. Select out all these 6 regions. That will define the area. We have to DIY this.\n\nFilter out from HDX (then write into rds)\n",
    "supporting": [
      "Take-home_Ex01_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}