{
  "hash": "8f4a7af092477862fb6394190afe6b81",
  "result": {
    "markdown": "---\ntitle: \"In-class Exercise 5\"\nauthor: \"Leow Xian Zu\"\ndate: \"23 Sep 2024\"\ndate-modified: \"last-modified\"\nexecute:\n  eval: true\n  echo: true \n  message: false #no more warning message\n  freeze: true #whatever document already commited does not render\n---\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, sfdep, tmap, tidyverse)\n\nhunan <- st_read(dsn = \"C:/zzzzzuu/ISSS626GAA/Hands-on_Ex/Hands-on_Ex04/data/geospatial\", \n                 layer = \"Hunan\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `Hunan' from data source \n  `C:\\zzzzzuu\\ISSS626GAA\\Hands-on_Ex\\Hands-on_Ex04\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 88 features and 7 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n```\n:::\n\n```{.r .cell-code}\nhunan2012 <- read_csv(\"C:/zzzzzuu/ISSS626GAA/Hands-on_Ex/Hands-on_Ex04/data/aspatial/Hunan_2012.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 88 Columns: 29\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): County, City\ndbl (27): avg_wage, deposite, FAI, Gov_Rev, Gov_Exp, GDP, GDPPC, GIO, Loan, ...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\nhunan_GDPPC <- left_join(hunan,hunan2012) %>%\n  dplyr::select(1:4, 7, 15)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nJoining with `by = join_by(County)`\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\ntmap mode set to plotting\n```\n:::\n\n```{.r .cell-code}\ntm_shape(hunan_GDPPC) +\n  tm_fill(\"GDPPC\",\n          n = 5,\n          style = \"jenks\") +\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex05_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- hunan_GDPPC %>%\n  mutate(nb = st_contiguity(geometry), # This is different because we are using sfdep\n         wt = st_weights(nb,\n                         style = \"W\"), #W is row standardised weights. \"B\" \"C\" \"U\" \"minmax\" and \"S\" are also options. C is global standard, U is equal to C divided by neigbouts, S is variance stabilizing coding scheme. allow_zero: if true it assigns zero as lagged value to zone without neighbours.\n         .before = 1) #This means this tool makes new fields insert to the front.\n```\n:::\n\n\nTwo more fields added in, nb and wt. nb gives neighbour list. wt gives weights across rows.\n\nThis is handier than the spdep coz spdep needs to check one by one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoranI <- global_moran(wm_q$GDPPC,\n                       wm_q$nb,\n                       wm_q$wt)\nglimpse(moranI)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ I: num 0.301\n $ K: num 7.64\n```\n:::\n:::\n\n\nThis is only a calculation step. there's no p-value. No monte carlo. We will use test instead.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglobal_moran_test(wm_q$GDPPC,\n                  wm_q$nb,\n                  wm_q$wt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMoran I test under randomisation\n\ndata:  x  \nweights: listw    \n\nMoran I statistic standard deviate = 4.7351, p-value = 1.095e-06\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n      0.300749970      -0.011494253       0.004348351 \n```\n:::\n:::\n\n\np-value smaller than alpha. We have enough statistical evidence to reject the null hypothesis that the pattern is random. Look at the sign, the statistic is 0.3 . Low, but got signs of positive autocorrelation. Means there is some clustering.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nglobal_moran_perm(wm_q$GDPPC,\n                  wm_q$nb,\n                  wm_q$wt,\n                  nsim=99)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tMonte-Carlo simulation of Moran I\n\ndata:  x \nweights: listw  \nnumber of simulations + 1: 100 \n\nstatistic = 0.30075, observed rank = 100, p-value < 2.2e-16\nalternative hypothesis: two.sided\n```\n:::\n:::\n\n\np-value even smaller. Because of more iterations. Each have a result. Large number theory.\n\nI have 88 polygons, when I run the permutations, it is faster than point pattern.\n\nNetx, local moran's\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa <- wm_q %>%\n  mutate(local_moran = local_moran(\n    GDPPC, nb, wt, nsim = 99),\n    .before = 1) %>%\n  unnest(local_moran) #Instead of a list, it puts into a table.\n```\n:::\n\n\n1.  ii: Local Moran's I statistic\n\n    -   Indicates the strength and type of spatial autocorrelation for each location\n\n    -   Positive values suggest similarity with neighbors, negative values suggest dissimilarity\n\n2.  e.ii: Expected value of ii under the null hypothesis of no spatial autocorrelation\n\n    -   Used as a reference point to compare against the observed Ii\n\n3.  var_ii: Variance of ii\n\n    -   Measures the variability of the Local Moran's I statistic\n\n    -   Used in calculating significance\n\n4.  z.ii: Z-score of ii\n\n    -   Standardized score indicating how many standard deviations Ii is from its expected value\n\n    -   Used to assess statistical significance\n\n5.  p_ii: p-value for ii\n\n    -   Probability of obtaining the observed Ii value under the null hypothesis\n\n    -   Used to determine statistical significance (typically compared to a threshold like 0.05)\n\n6.  p_ii_sim and p_folded_sim: Simulated p-values\n\n    -   Alternative measures of significance based on Monte Carlo simulations\n\n    -   Useful for more robust significance testing, especially with non-normal data\n\n7.  Skewness and Kurtosis:\n\n    -   Describe the shape of the distribution of simulated values\n\n    -   Help assess the validity of assumptions in your analysis\n\n8.  Cluster_type:\n\n    -   Categorizes each location based on its relationship with neighbors\n\n    -   Typically includes categories like \"High-High\", \"Low-Low\", \"High-Low\", \"Low-High\"\n\n9.  Median and Pysal:\n\n    -   These appear to be factor variables, possibly indicating alternative classification methods\n\n    -   Can be used to compare different ways of categorizing spatial relationships\n\nWhat you can do with these results:\n\n1.  Identify significant clusters or outliers using the p-values and cluster types\n\n2.  Map the results to visualize spatial patterns\n\n3.  Investigate locations with particularly high or low ii values\n\n4.  Compare observed patterns with what you'd expect theoretically (using e.ii)\n\n5.  Use the cluster types to inform further analyses or policy decisions\n\n6.  Assess the robustness of your results by comparing different significance measures (p_ii vs p_ii_sim)\n\n7.  Check for potential issues in your data or analysis using the skewness and kurtosis values\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\ntmap mode set to plotting\n```\n:::\n\n```{.r .cell-code}\nmap1 <- tm_shape(lisa) + \n  tm_fill(\"ii\")+\n  tm_borders(alpha=0.5)+\n  tm_layout(main.title=\"p-value\",\n            main.title.size=2)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\ntmap mode set to plotting\n```\n:::\n\n```{.r .cell-code}\nmap2 <- tm_shape(lisa) + \n  tm_fill(\"p_ii_sim\")+\n  tm_borders(alpha=0.5)+\n  tm_layout(main.title=\"p-value\",\n            main.title.size=2)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_arrange(map1, \n             map2, \n             asp=1, #Aspect Ratio\n             ncol=2)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nVariable(s) \"ii\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n```\n:::\n\n::: {.cell-output-display}\n![](In-class_Ex05_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlisa_sig <- lisa %>%\n  filter(p_ii < 0.05)\n\ntm_shape(lisa) +\n  tm_polygons()+\n  tm_shape(lisa_sig)+\n  tm_fill(\"mean\")+\n  tm_borders(alpha=0.5)+\n  tm_layout(main.title=\"Mean\",\n            main.title.size=2)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex05_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nRed ones mean high surrounded by high.\n\npurple are outliers, low surrounded by high.\n\ngreen is not an outlier, but a cluster which is a low low cluster. That is where it is tricky. It's the only one because the others got filtered away.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_idw <- hunan_GDPPC %>%\n  mutate(nb = include_self(st_contiguity(geometry)),\n         wts = st_inverse_distance(nb, geometry, \n                                   scale = 1,\n                                   alpha = 1),\n         .before = 1)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n! Polygon provided. Using point on surface.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: There was 1 warning in `stopifnot()`.\nℹ In argument: `wts = st_inverse_distance(nb, geometry, scale = 1, alpha = 1)`.\nCaused by warning in `st_point_on_surface.sfc()`:\n! st_point_on_surface may not give correct results for longitude/latitude data\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nHCSA <- wm_idw %>%\n  mutate(local_Gi = local_gstar_perm(\n    GDPPC, nb, wts, nsim=99),\n    .before = 1) %>%\n  unnest(local_Gi)\nHCSA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 88 features and 18 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 108.7831 ymin: 24.6342 xmax: 114.2544 ymax: 30.12812\nGeodetic CRS:  WGS 84\n# A tibble: 88 × 19\n    gi_star cluster     e_gi  var_gi std_dev p_value p_sim p_folded_sim skewness\n      <dbl> <fct>      <dbl>   <dbl>   <dbl>   <dbl> <dbl>        <dbl>    <dbl>\n 1  0.261   Low     0.00126  1.07e-7  0.283  7.78e-1  0.66         0.33    0.783\n 2 -0.276   Low     0.000969 4.76e-8 -0.123  9.02e-1  0.98         0.49    0.713\n 3  0.00573 High    0.00156  2.53e-7 -0.0571 9.54e-1  0.78         0.39    0.972\n 4  0.528   High    0.00155  2.97e-7  0.321  7.48e-1  0.56         0.28    0.942\n 5  0.466   High    0.00137  2.76e-7  0.386  7.00e-1  0.52         0.26    1.32 \n 6 -0.445   High    0.000992 7.08e-8 -0.588  5.57e-1  0.68         0.34    0.692\n 7  2.99    High    0.000700 4.05e-8  3.13   1.74e-3  0.04         0.02    0.975\n 8  2.04    High    0.00152  1.58e-7  1.77   7.59e-2  0.16         0.08    1.26 \n 9  4.42    High    0.00130  1.18e-7  4.22   2.39e-5  0.02         0.01    1.20 \n10  1.21    Low     0.00175  1.25e-7  1.49   1.36e-1  0.18         0.09    0.408\n# ℹ 78 more rows\n# ℹ 10 more variables: kurtosis <dbl>, nb <nb>, wts <list>, NAME_2 <chr>,\n#   ID_3 <int>, NAME_3 <chr>, ENGTYPE_3 <chr>, County <chr>, GDPPC <dbl>,\n#   geometry <POLYGON [°]>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\ntmap mode set to plotting\n```\n:::\n\n```{.r .cell-code}\nHCSA_sig <- HCSA %>%\n  filter(p_sim < 0.05)\nmap4 <- tm_shape(HCSA) + \n  tm_polygons()+\n  tm_shape(HCSA_sig)+\n  tm_fill(\"cluster\")+\n  tm_borders(alpha=0.5)+\n  tm_layout(main.title=\"hot and cold spot\",\n            main.title.size=2)\nmap5 <- tm_shape(HCSA) + \n  tm_fill(\"p_sim\")+\n  tm_borders(alpha=0.5)+\n  tm_layout(main.title=\"p-value\",\n            main.title.size=2)\ntmap_arrange(map4, map5,ncol = 2)\n```\n\n::: {.cell-output-display}\n![](In-class_Ex05_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "In-class_Ex05_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}