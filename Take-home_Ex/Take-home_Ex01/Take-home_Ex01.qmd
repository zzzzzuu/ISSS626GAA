---
title: "Take-home Exercise 1"
author: "Leow Xian Zu"
date: "2 Sep 2024"
date-modified: "last-modified"
execute:
  eval: true
  echo: true 
  message: false #no more warning message
  freeze: true #whatever document already commited does not render
---

# Set up

## Load packages

```{r}

pacman::p_load(
  readr,       # for importing data
  tidyverse,    # for data manipulation and visualization
  sf,           # for spatial data handling
  tmap,         # for thematic maps
  lubridate,    # for date/time manipulation
  spatstat,     # for point pattern analysis
  ggstatsplot,  # for statistical data viz
  maptools,     # for spatial object manipulation
  raster,       # for raster data handling
  sp,           # for spatial data classes and methods
  leaflet,      # for interactive maps
  ggplot2,      # for advanced plotting
  spNetwork     # for spatial network analysis
)
set.seed(1234)
```

## Load files

In this section, we will load and prepare the datasets necessary for our analysis of road traffic accidents in the Bangkok Metropolitan Region (BMR). The BMR, also known as Greater Bangkok, encompasses the city of Bangkok and its surrounding provinces. According to Wikipedia, this area includes Bangkok itself and five adjacent provinces: Nakhon Pathom, Pathum Thani, Nonthaburi, Samut Prakan, and Samut Sakhon. Our analysis will focus on this region, which serves as the political, economic, and cultural heart of Thailand.

We'll be working with three primary datasets: Thailand Road Accident data from 2019-2022, road network data from OpenStreetMap, and administrative boundary data. These datasets will allow us to conduct a comprehensive spatio-temporal analysis of road traffic accidents in this densely populated and economically significant area of Thailand.

## Data Wrangling 1: Correct Coordinate Reference System

In preparing our analysis of road traffic accidents in the Bangkok Metropolitan Region, care is taken to ensure our data is accurate and spatially consistent. First, we import the road accident data from 2019 to 2022 using `read_csv()`, a function chosen for its robust handling of various CSV formats (includes automatic reading of headers and correct tagging of date and time columns). Crucially, we filter out records with missing or empty longitude and latitude values. This step is vital as geographic coordinates are the cornerstone of our spatial analysis; including records without valid locations would skew our results and potentially lead to misleading conclusions about accident patterns.

We then transform this data into a spatial format using `st_as_sf()`. This conversion is essential as it allows us to perform spatial operations and visualisations. We specify the coordinate reference system (CRS) as EPSG:32647, which is tailored for Thailand. This was double-checked on https://epsg.io/. This choice is deliberate - using a local CRS ensures more accurate distance calculations and area representations compared to a global system like WGS84. For the road network data, sourced from OpenStreetMap, we employ `st_read()` to load the shapefile. Recognizing that OSM data can sometimes contain geometry inconsistencies, we apply `st_make_valid()`. This crucial step corrects any invalid geometries that could potentially crash our analysis or produce erroneous results in spatial operations. Lastly, we import administrative boundary data, again ensuring it aligns with our chosen CRS.

```{r}
#| eval: false
rdacc_sf <- read_csv("C:/zzzzzuu/ISSS626GAA/Take-home_Ex/Take-home_Ex01/data/thai_road_accident_2019_2022.csv") %>%
  filter(!is.na(longitude) & longitude != "",
         !is.na(latitude) & latitude != "") %>%
  st_as_sf(coords = c(
    "longitude", "latitude"),
    crs=4326) %>%  #WGS84, decimel degree
  st_transform(crs = 32647)  #32647 is Thai's
#read_csv from Readr is better than read.csv base R. It matters for headers with spacing, and also can autodetect dates. 

roads_sf <- st_read("C:/zzzzzuu/ISSS626GAA/Take-home_Ex/Take-home_Ex01/data/hotosm_tha_roads_lines_shp.shp") %>%
  st_make_valid() %>%
  st_set_crs(4326) %>%
  st_transform(crs = 32647)

admin_sf <- st_read(dsn = "C:/zzzzzuu/ISSS626GAA/Take-Home_Ex/Take-Home_Ex01/data", layer = "tha_admbnda_adm1_rtsd_20220121") %>%
  st_set_crs(4326) %>%
  st_transform(crs = 32647)

```

Need to check unit of measurement!!!! See how to convert.

```{r}
#| eval: false
class(admin_sf)
class(rdacc_sf)
class(roads_sf)
```

## Check date and time format (POSIXct)

```{r}
#| eval: false
class(rdacc_sf$incident_datetime)
class(rdacc_sf$report_datetime)
```

The incident_datetime and report_datetime fields are stored in POSIXct format, a structure that captures year, month, date, and time information. This format allows for easy extraction of specific temporal components such as month, day of the year, or year via lubridate package. The level of detail and flexibility in datetime handling is only available when the data is properly imported and parsed using readr.

## Data Wrangling 2: Filtering to a smaller subset of data

The initial datasets cover all of Thailand and include various road types. To focus on the Bangkok Metropolitan Region (BMR), a spatial filter is applied to extract data for Bangkok and its five adjacent provinces: Nakhon Pathom, Pathum Thani, Nonthaburi, Samut Prakan, and Samut Sakhon. This step reduces data volume and ensures geographic relevance. Additionally, the road network data is filtered to include only roads accessible to motor vehicles, excluding roads like pedestrian paths and cycling lanes. These filtering processes enhance the accuracy of the subsequent analysis by focusing on relevant geographic areas and road types where motor vehicle accidents are likely to occur.

```{r}
#| eval: false
bangkok_areas <- c("Bangkok",
                   "Nonthaburi",
                   "Samut Prakan",
                   "Pathum Thani",
                   "Samut Sakhon",
                   "Nakhon Pathom")

admin_sf_bkk <- admin_sf %>%
  filter(!is.na(ADM1_EN) & ADM1_EN %in% bangkok_areas)
unique(admin_sf_bkk$ADM1_EN)     #check
plot(st_geometry(admin_sf_bkk))  #check
st_geometry_type(admin_sf_bkk)   #check

rdacc_sf_bkk <- rdacc_sf %>%
  filter(!is.na(province_en) & province_en %in% bangkok_areas)
unique(rdacc_sf_bkk$province_en) #check
plot(st_geometry(rdacc_sf_bkk))  #check

roads_sf_bkk <- st_intersection(roads_sf, admin_sf_bkk)
unique(roads_sf_bkk$highway)     #check
roads_sf_bkk_veh <- roads_sf_bkk %>%
  filter(!is.na(highway) & 
           !(highway %in% c("pedestrian",
                            "bridleway",
                            "cycleway",
                            "footway",
                            "steps",
                            "path")))
plot(st_geometry(roads_sf_bkk_veh)) #check

```

::: callout-tip
## Thailand Highway Classification

Refer to https://wiki.openstreetmap.org/wiki/WikiProject_Thailand#Highway_classification for definitions of different roads and access that is legally allowed.
:::

## Converting MULTILINESTRINGs to LINESTRINGs

The road network data contains both linestrings and multilinestrings. Multilinestrings represent complex road segments with multiple connected lines, while linestrings are single, continuous lines. Converting all geometries to linestrings simplifies the data structure, ensuring uniformity across the dataset, and makes it easier for lixelisation. This conversion is necessary for consistent analysis, as many spatial operations work more efficiently with simple linestring geometries.

```{r}
#| eval: false
geometry_types <- roads_sf_bkk_veh %>%
  st_geometry_type() %>%
  as.character() %>%
  unique()

if(length(geometry_types) == 1 && geometry_types == "LINESTRING") {
  print("All geometries are LINESTRING")
} else {
  print("Not all geometries are LINESTRING. Types found:")
  print(geometry_types)
}


roads_sf_bkk_veh_ls <- roads_sf_bkk_veh %>%
  st_cast("MULTILINESTRING", group_or_split = TRUE) %>%  
  st_cast("LINESTRING")


geometry_types <- roads_sf_bkk_veh_ls %>%
  st_geometry_type() %>%
  as.character() %>%
  unique()

if(length(geometry_types) == 1 && geometry_types == "LINESTRING") {
  print("All geometries are LINESTRING")
} else {
  print("Not all geometries are LINESTRING. Types found:")
  print(geometry_types)
}
```

## Write a smaller subset of the data for easier compute times

This segment makes our data smaller and easier to work with. It is savedin a special format (RDS) in a 'sandbox' folder. This helps my computer run faster and keeps the project tidy. I used commands to save and load data, and tell some parts of our code not to run again if not needed.

```{r}
#| eval: false
write_rds(roads_sf_bkk_veh_ls, "data/sandbox/roads.rds")
write_rds(rdacc_sf_bkk, "data/sandbox/rdacc.rds")
write_rds(admin_sf_bkk, "data/sandbox/admin.rds")

```

```{r}
roads <- read_rds("data/sandbox/roads.rds")
rdacc <- read_rds("data/sandbox/rdacc.rds")
admin <- read_rds("data/sandbox/admin.rds")
```

# Overall Analysis

Roads dataset is still too dense. It is difficult to make meaningful insights out of it, so we will drop more, smaller roads.

```{r}
unique(roads$highway)
roads_filtered <- roads %>%
  filter(!is.na(highway) & 
           (highway %in% c("secondary",
                           "secondary_link",
                           "primary",
                           "primary_link",
                           "trunk_link",
                           "trunk",
                           "motorway",
                           "motorway_link",
                           "tertiary_link",
                           "tertiary")))
plot(st_geometry(roads_filtered))
```

```{r}
#| eval: false
tmap_mode('plot')
tm_shape(rdacc) +
  tm_dots(col = "red", size = 0.1) +
  tm_shape(roads_filtered) +
  tm_lines()
```

```{r}
#| eval: false
tmap_mode('plot')
```

## Lixelisation

To prepare for Network Kernel Density Estimation (NKDE), the road network is divided into small, equal segments called lixels using the lixelize_lines() function from the spNetwork package. Lixels are like pixels for lines, allowing more precise analysis along the network. This process is crucial for accurately studying patterns of childcare centers along the road network. It creates a consistent unit of measurement, which is especially useful when dealing with irregular network structures.

```{r}
#| eval: false
lixels <- lixelize_lines(roads_filtered, 
                         700, 
                         mindist = 500)
samples <- lines_center(lixels) 
densities <- nkde(roads_filtered, 
                  events = rdacc,
                  w = rep(1, nrow(rdacc)),
                  samples = samples,
                  kernel_name = "quartic",
                  bw = 100, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(4,4), 
                  max_depth = 8,
                  agg = 5, 
                  sparse = TRUE,
                  verbose = FALSE)
samples$density <- densities
lixels$density <- densities
summary(samples$density)


```

The values seem small. The measurements must be in metres. Let's correct that to km later. Let's save the lixelised data first.

```{r}
#| eval: false
write_rds(lixels, "data/sandbox/lixels.rds")
write_rds(samples, "data/sandbox/samples.rds")
```

```{r}
lixels <- read_rds("data/sandbox/lixels.rds")
samples <- read_rds("data/sandbox/samples.rds")
samples$density <- samples$density*1000
lixels$density <- lixels$density*1000
summary(samples$density)
summary(lixels$density)
```

That looks better. Seems that the hotspots are quite scant and concentrated at the top. It would be good to merge everything below the mean, while having more granular breaks in the top quartile to examine the hot spots in more detail.

Let's try to plot it.

## Overall situation of road accidents in BMR

```{r}

lixels$display_name <- ifelse(is.na(lixels$name_en), 
                              paste(lixels$highway,": Unnamed Road"),
                              paste(lixels$highway,": ",lixels$name_en))

tmap_mode('plot')
custom_breaks <- c(0, quantile(lixels$density, c(0.85, 
                                                 0.9, 
                                                 0.95,
                                                 0.99, 
                                                 1)))
tm_shape(lixels) +
  tm_lines(col = "density",
           id = "display_name",
           breaks = custom_breaks,
           palette = "YlOrRd",
           lwd = 1.5)+
  tm_shape(admin) +  
  tm_borders(col = "black", lwd = 2, alpha = 0.5)



```

```{r}
tmap_mode('plot')
```

The accident density map of Bangkok and its surrounding provinces reveals significant patterns in road safety across the region. The central area, primarily Bangkok, exhibits the highest concentration of accident hotspots, indicating a greater risk in the urban core. This concentration likely correlates with higher population density, increased traffic volume, and more complex road networks typical of major city centers.

While accident density generally decreases towards the outskirts, there are notable hotspots in the peripheral areas surrounding Bangkok. These could represent key transportation corridors or rapidly developing suburban zones with high traffic flow.

The skewed distribution of accident densities, as shown in the legend, highlights the presence of extreme hotspots amid generally moderate-to-high risk areas. This pattern underscores the need for targeted interventions in specific high-risk locations while also addressing broader regional safety concerns. We should look into them.

# Deeper dive analysis

## Temporal analysis of road accidents

In the following analysis, let's examine temporal patterns of road accidents in the Bangkok Metropolitan Region from 2019 to 2022. Let's visualize accident frequencies across different time scales, including hours of the day, days of the week, months, and years. This temporal breakdown will help identify high-risk periods influencing accident rates.

```{r}
# Ensure datetime columns are properly formatted
rdacc$incident_datetime <- ymd_hms(rdacc$incident_datetime)

# Create new columns for analysis
rdacc_inc <- rdacc %>%
  mutate(
    hour = hour(incident_datetime),
    day_of_week = wday(incident_datetime, label = TRUE),
    month = month(incident_datetime, label = TRUE),
    year = year(incident_datetime)
  )

# Accidents by hour of day
ggplot(rdacc_inc, aes(x = hour)) +
  geom_bar() +
  labs(title = "Accidents by Hour of Day", x = "Hour", y = "Number of Accidents")

#Insight: Accidents appear to happen from 7am to 11am and 7pm.

# Accidents by day of week
ggplot(rdacc_inc, aes(x = day_of_week)) +
  geom_bar() +
  labs(title = "Accidents by Day of Week", x = "Day", y = "Number of Accidents")

#Insight: Accidents appear to happen on Friday and Saturday.

# Accidents by month
ggplot(rdacc_inc, aes(x = month)) +
  geom_bar() +
  labs(title = "Accidents by Month", x = "Month", y = "Number of Accidents")

#Insight: Accidents appear to happen In Dec, Jan, Apr, and Oct.

# Time series of accidents by date
rdacc_inc %>%
  count(date = as.Date(incident_datetime)) %>%
  ggplot(aes(x = date, y = n)) +
  geom_line() +
  labs(title = "Daily Accident Counts Over Time", x = "Date", y = "Number of Accidents")

#Insight: Accidents spike every year in Jan/ Dec and Apr.

# Time series of accidents by year
ggplot(rdacc_inc, aes(x = year)) +
  geom_bar() +
  labs(title = "Accidents by Year", x = "Year", y = "Number of Accidents")

#Insight: Fluctuating with a graduate increase per year.
```

Let's take a look at two heatmaps that examines when accidents happen.

```{r}
library(viridis)

rdacc_time <- rdacc %>%
  mutate(
    month = month(incident_datetime, label = TRUE, abbr = TRUE),
    hour = hour(incident_datetime)
  )

accident_counts <- rdacc_time %>%
  count(month, hour)

ggplot(accident_counts, aes(x = hour, y = month, fill = n)) +
  geom_tile() +
  scale_fill_viridis(name = "Number of Accidents", 
                     option = "inferno", 
                     breaks = seq(20, 80, by = 20),
                     limits = c(20, 80)) +
  scale_x_continuous(breaks = seq(0, 23, by = 3), 
                     labels = c("12am", "3am", "6am", "9am", "12pm", "3pm", "6pm", "9pm")) +
  scale_y_discrete(limits = rev(levels(accident_counts$month))) +
  labs(title = "Heatmap of Accidents by Month and Time of Day",
       subtitle = "Bangkok Metropolitan Region, 2019-2022",
       x = "Time of Day",
       y = "Month") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 12, color = "gray50"),
    axis.title = element_text(face = "bold")
  )
```

It appears that Jan, Apr, Oct, Dec, but hotspots are different. Jan and Dec hotspots are in the morning peak, while Apr and Oct hotspots are in the evening peak. This heatmap visualizes the distribution of road accidents in the Bangkok Metropolitan Region from 2019 to 2022, broken down by month and time of day.

Key observations:

1.  Time patterns: The highest concentration of accidents occurs between 9am and 9pm, with peak intensity around midday and early afternoon.

2.  Seasonal trends: December shows consistently high accident rates throughout the day. This could be related to increased holiday traffic or year-end celebrations.

3.  Morning trends: There's a noticeable increase in accidents starting around 6am across most months, likely corresponding to morning rush hour.

4.  Night-time patterns: Accident rates generally decrease late at night (12am-3am), but remain somewhat elevated compared to early morning hours (3am-6am).

5.  Variability: The heatmap shows considerable variation both across months and times of day, suggesting multiple factors influence accident occurrence.

6.  Hotspots: Several distinct "hotspots" of high accident frequency are visible, particularly during daytime hours in certain months like April, July, and December.

This visualization provides valuable insights for targeting road safety initiatives. Focusing on high-risk times and seasons could help authorities allocate resources more effectively to reduce accident rates in the Bangkok Metropolitan Region.

```{r}
rdacc_wday <- rdacc %>%
  mutate(
    wday = wday(incident_datetime, label = TRUE, abbr = TRUE),
    hour = hour(incident_datetime)
  )

accident_counts <- rdacc_wday %>%
  count(wday, hour)

ggplot(accident_counts, aes(x = hour, y = wday, fill = n)) +
  geom_tile() +
  scale_fill_viridis(name = "Number of Accidents", 
                     option = "inferno",
                     trans = "sqrt")  +
  scale_x_continuous(breaks = seq(0, 23, by = 3), 
                     labels = c("12am", "3am", "6am", "9am", "12pm", "3pm", "6pm", "9pm")) +
  scale_y_discrete(limits = rev(levels(accident_counts$wday))) +
  labs(title = "Heatmap of Accidents by Day of Week and Time of Day",
       subtitle = "Bangkok Metropolitan Region, 2019-2022",
       x = "Time of Day",
       y = "Day of Week") +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = "right",
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 12, color = "gray50"),
    axis.title = element_text(face = "bold")
  )

#Insight: Hotspots are Monday and Tuesday mornings, Friday and Saturday evenings. 
```

```{r}
tm_shape(mpsz_pop2020) +
  tm_fill("DEPENDENCY",
          style = "quantile",
          palette = "Blues",
          thres.poly = 0) + 
  tm_facets(by="REGION_N", 
            free.coords=TRUE, 
            drop.shapes=TRUE) +
  tm_layout(legend.show = FALSE,
            title.position = c("center", "center"), 
            title.size = 20) +
  tm_borders(alpha = 0.5)
```

```{r}

rdacc_apr <- rdacc %>%
  filter(month(incident_datetime) == 4)

lixels_apr <- lixelize_lines(roads_filtered, 
                         700, 
                         mindist = 500)
samples_apr <- lines_center(lixels_apr) 
densities_apr <- nkde(roads_filtered, 
                  events = rdacc_apr,
                  w = rep(1, nrow(rdacc_apr)),
                  samples = samples_apr,
                  kernel_name = "quartic",
                  bw = 100, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(4,4), 
                  max_depth = 8,
                  agg = 5, 
                  sparse = TRUE,
                  verbose = FALSE)
samples_apr$density <- densities_apr
lixels_apr$density <- densities_apr
summary(samples_apr$density)


```

```{r}
write_rds(lixels_apr, "data/sandbox/lixels_apr.rds")
write_rds(samples_apr, "data/sandbox/samples_apr.rds")
```

```{r}
lixels_apr <- read_rds("data/sandbox/lixels_apr.rds")
samples_apr <- read_rds("data/sandbox/samples_apr.rds")
samples_apr$density <- samples_apr$density*1000
lixels_apr$density <- lixels_apr$density*1000
summary(samples_apr$density)
summary(lixels_apr$density)
```

```{r}
lixels_apr$display_name <- ifelse(is.na(lixels_apr$name_en), 
                              paste(lixels_apr$highway,": Unnamed Road"),
                              paste(lixels_apr$highway,": ",lixels_apr$name_en))

tmap_mode('view')
custom_breaks <- c(0, quantile(lixels_apr$density, c(0.99,
                                                     0.992,
                                                     0.994,
                                                     0.996,
                                                     0.998,
                                                     1)))
tm_shape(lixels_apr) +
  tm_lines(col = "density",
           id = "display_name",
           breaks = custom_breaks,
           palette = "YlOrRd",
           lwd = 1.5)+
  tm_shape(admin) +  
  tm_borders(col = "black", lwd = 2, alpha = 0.5)

tmap_mode('plot')
```

Accidents are spread across the entire region, but with varying densities

pattern of higher-density areas seems to follow certain lines or corridors, which likely correspond to major roads or highways where traffic is heavier.

```{r}
rdacc_jandec <- rdacc %>%
  filter(month(incident_datetime) %in% c(1, 12))

lixels_jandec <- lixelize_lines(roads_filtered, 
                         700, 
                         mindist = 500)
samples_jandec <- lines_center(lixels_jandec) 
densities_jandec <- nkde(roads_filtered, 
                  events = rdacc_jandec,
                  w = rep(1, nrow(rdacc_jandec)),
                  samples = samples_jandec,
                  kernel_name = "quartic",
                  bw = 100, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(4,4), 
                  max_depth = 8,
                  agg = 5, 
                  sparse = TRUE,
                  verbose = FALSE)
samples_jandec$density <- densities_jandec
lixels_jandec$density <- densities_jandec
summary(samples_jandec$density)
```

```{r}
write_rds(lixels_jandec, "data/sandbox/lixels_jandec.rds")
write_rds(samples_jandec, "data/sandbox/samples_jandec.rds")
```

```{r}
lixels_jandec <- read_rds("data/sandbox/lixels_jandec.rds")
samples_jandec <- read_rds("data/sandbox/samples_jandec.rds")
samples_jandec$density <- samples_jandec$density*1000
lixels_jandec$density <- lixels_jandec$density*1000
summary(samples_jandec$density)
summary(lixels_jandec$density)
```

```{r}
lixels_jandec$display_name <- ifelse(is.na(lixels_jandec$name_en), 
                              paste(lixels_jandec$highway,": Unnamed Road"),
                              paste(lixels_jandec$highway,": ",lixels_jandec$name_en))

tmap_mode('view')
custom_breaks <- c(0, quantile(lixels_jandec$density, c(0.99,
                                                     0.992,
                                                     0.994,
                                                     0.996,
                                                     0.998,
                                                     1)))
tm_shape(lixels_jandec) +
  tm_lines(col = "density",
           id = "display_name",
           breaks = custom_breaks,
           palette = "YlOrRd",
           lwd = 1.5)+
  tm_shape(admin) +  
  tm_borders(col = "black", lwd = 2, alpha = 0.5)

tmap_mode('plot')
```

**WIP Segment below**\*

# Network constrained G and L function analysis

In this section, we are going to perform complete spatial randomness (CSR) test by using *kfunctions()* of **spNetwork** package. The null hypothesis is defined as:

**Ho: The observed spatial point events (i.e distribution of childcare centres) are uniformly distributed over a street network in Punggol Planning Area.**

The CSR test is based on the assumption of the binomial point process which implies the hypothesis that the childcare centres are randomly and independently distributed over the street network.

If this hypothesis is rejected, we may infer that the distribution of accidents are spatially interacting and dependent on each other; as a result, they may form nonrandom patterns.

```{r}
#| eval: false
rdacc_asspatial <- as_Spatial(rdacc)
rdacc_sp <- as(rdacc_asspatial, "SpatialPoints")
rdacc_ppp <- as.ppp(rdacc_sf)
plot(rdacc_ppp)
summary(rdacc_ppp)
any(duplicated(rdacc_ppp))
tmap_mode('view')
tm_shape(rdacc) +
  tm_dots(alpha=0.4, 
          size=0.05)
```

```{r}
tmap_mode('plot')
```

```{r}
#| eval: false
rdacc_ppp_jit <- rjitter(rdacc_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
admin_owin <- as.owin(admin)
plot(admin_owin)
```

```{r}
#| eval: false
# Apply jitter to the spatial coordinates
rdacc_jittered <- st_jitter(rdacc, amount = 0.01)

kfun_rdacc <- kfunctions(roads_filtered, 
                             rdacc_jittered,
                             start = 0, 
                             end = 300, 
                             step = 100, 
                             width = 50, 
                             nsim = 30, 
                             resolution = 50,
                             verbose = FALSE, 
                             conf_int = 0.05,
                         agg= 400)
```

```{r}
#| eval: false
kfun_rdacc$plotk
```

## Creating date and time analysis

WIP
